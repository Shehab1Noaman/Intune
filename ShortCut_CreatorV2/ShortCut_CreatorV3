# Intune Win32 Shortcut Packaging Script - Enhanced Single GUI Version (All Fixes Applied)

#region Add Required Assemblies
Add-Type -AssemblyName System.Windows.Forms
Add-Type -AssemblyName System.Drawing
#endregion

# Ensure the script is running in the correct directory
Set-Location -Path $PSScriptRoot

#region Logger Function
function Write-Log {
    param (
        [string]$Message,
        [string]$LogFile
    )
    $TimeStamp = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss")
    $LogMessage = "$TimeStamp - $Message"

    # Write log to file
    try {
        $LogMessage | Out-File -FilePath $LogFile -Append -Encoding UTF8
    }
    catch {
        # Fallback if logging to file fails (e.g., permissions)
        Write-Host "WARNING: Could not write to log file $LogFile. Message: $($_.Exception.Message)"
    }
}
#endregion

#region GUI Helper Functions

# Function to display a GUI popup for file selection
function Get-FileBrowserInput {
    param (
        [string]$Title,
        [string]$Filter = "All Files (*.*)|*.*",
        [string]$InitialDirectory = (Get-Location).Path
    )
    Write-Log -Message "Get-FileBrowserInput called. Title: '$Title', Filter: '$Filter', InitialDirectory: '$InitialDirectory'" -LogFile $Script:LogFile

    try {
        $OpenFileDialog = New-Object System.Windows.Forms.OpenFileDialog
        $OpenFileDialog.Title = $Title
        $OpenFileDialog.Filter = $Filter # Standard filter assignment
        $OpenFileDialog.InitialDirectory = $InitialDirectory
        $OpenFileDialog.RestoreDirectory = $true # Standard boolean assignment
        $OpenFileDialog.CheckFileExists = $true   # Standard boolean assignment
        $OpenFileDialog.CheckPathExists = $true   # Standard boolean assignment

        $dialogResult = $OpenFileDialog.ShowDialog()
        Write-Log -Message "File dialog result: '$dialogResult'" -LogFile $Script:LogFile

        if ($dialogResult -eq [System.Windows.Forms.DialogResult]::OK) {
            Write-Log -Message "Selected file: '$($OpenFileDialog.FileName)'" -LogFile $Script:LogFile
            return $OpenFileDialog.FileName
        } else {
            Write-Log -Message "File selection cancelled." -LogFile $Script:LogFile
            return $null # User cancelled
        }
    }
    catch {
        $errorMessage = "Error in Get-FileBrowserInput: $($_.Exception.Message)"
        Write-Log -Message $errorMessage -LogFile $Script:LogFile
        [System.Windows.Forms.MessageBox]::Show($errorMessage, "Error", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Error)
        return $null
    }
}

# Function to display a GUI popup for folder selection
function Get-FolderBrowserInput {
    param (
        [string]$Title,
        [string]$InitialDirectory = (Get-Location).Path
    )
    Write-Log -Message "Get-FolderBrowserInput called. Title: '$Title', InitialDirectory: '$InitialDirectory'" -LogFile $Script:LogFile

    try {
        $FolderBrowserDialog = New-Object System.Windows.Forms.FolderBrowserDialog
        $FolderBrowserDialog.Description = $Title
        $FolderBrowserDialog.SelectedPath = $InitialDirectory
        $FolderBrowserDialog.ShowNewFolderButton = $true # Standard boolean assignment

        $dialogResult = $FolderBrowserDialog.ShowDialog()
        Write-Log -Message "Folder dialog result: '$dialogResult'" -LogFile $Script:LogFile

        if ($dialogResult -eq [System.Windows.Forms.DialogResult]::OK) {
            Write-Log -Message "Selected folder: '$($FolderBrowserDialog.SelectedPath)'" -LogFile $Script:LogFile
            return $FolderBrowserDialog.SelectedPath
        } else {
            Write-Log -Message "Folder selection cancelled." -LogFile $Script:LogFile
            return $null # User cancelled
        }
    }
    catch {
        $errorMessage = "Error in Get-FolderBrowserInput: $($_.Exception.Message)"
        Write-Log -Message $errorMessage -LogFile $Script:LogFile
        [System.Windows.Forms.MessageBox]::Show($errorMessage, "Error", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Error)
        return $null
    }
}

# Define the function to display the error message with an exit button
function Show-ErrorAndExit {
    param (
        [string]$Message,
        [string]$LogMessage = "",
        [string]$LogFile = ""
    )

    # Display a GUI message box with an Exit button
    [System.Windows.Forms.MessageBox]::Show(
        $Message,
        "Error",
        [System.Windows.Forms.MessageBoxButtons]::OK,
        [System.Windows.Forms.MessageBoxIcon]::Error
    )
    if($LogFile -ne "" -and $LogMessage -ne ""){
        # Log the error message to the log file
        Write-Log -Message $LogMessage -LogFile $LogFile
    }
    exit 1
}

# Check existing IntuneWinAppUtil file and confirm deletion
function DeleteFileWithConfirmation {
    param (
        [string]$FilePath,
        [string]$LogFile,
        [string]$FileNameForPrompt # To make the prompt more generic
    )

    Write-Log -Message "DeleteFileWithConfirmation called for '$FilePath'." -LogFile $LogFile
    # Show a Yes/No message box asking if the user wants to delete the file
    $result = [System.Windows.Forms.MessageBox]::Show("The $FileNameForPrompt file already exists in the destination folder. Do you want to delete it: $FilePath?",
                                                       "Delete File Confirmation",
                                                       [System.Windows.Forms.MessageBoxButtons]::YesNo,
                                                       [System.Windows.Forms.MessageBoxIcon]::Question)

    Write-Log -Message "Deletion confirmation dialog result: '$result'." -LogFile $LogFile
    # Check the result of the message box (Yes or No)
    if ($result -eq [System.Windows.Forms.DialogResult]::Yes) {
        # If Yes, delete the file
        try {
            Remove-Item $FilePath -Force -ErrorAction Stop
            Write-Log -Message "File '$FilePath' deleted successfully." -LogFile $LogFile
            return $true
        }
        catch {
            $errorMessage = "Failed to delete file '$FilePath'. Error: $($_.Exception.Message)"
            Show-ErrorAndExit -Message $errorMessage -LogMessage $errorMessage -LogFile $LogFile
            return $false
        }
    } else {
        # If No, exit the script
        Show-ErrorAndExit -Message 'The process has been canceled. Please rerun the script and choose another output path or allow deletion.'`
                          -LogMessage 'File deletion canceled by user. Exiting script.' -LogFile $LogFile
        return $false
    }
}

# Function to show an indeterminate progress window
function Show-ProgressWindow {
    param (
        [string]$Title = "Processing...",
        [string]$Message = "Please wait while the operation completes."
    )

    $Form = New-Object System.Windows.Forms.Form
    $Form.Text = $Title
    $Form.Size = New-Object System.Drawing.Size(400, 150)
    $Form.StartPosition = 'CenterScreen'
    $Form.FormBorderStyle = [System.Windows.Forms.FormBorderStyle]::FixedDialog
    $Form.MinimizeBox = $false # Standard boolean assignment
    $Form.MaximizeBox = $false # Standard boolean assignment
    $Form.ControlBox = $false  # Standard boolean assignment # Disable close button
    $Form.TopMost = $true     # Standard boolean assignment # Keep on top

    $Label = New-Object System.Windows.Forms.Label
    $Label.Text = $Message
    $Label.Left = 20
    $Label.Top = 20
    $Label.Width = $Form.ClientSize.Width - 40
    $Label.AutoSize = $true # Standard boolean assignment
    $Label.Font = [System.Drawing.Font]::new("Microsoft Sans Serif", 10)
    $Form.Controls.Add($Label)

    $ProgressBar = New-Object System.Windows.Forms.ProgressBar
    $ProgressBar.Style = [System.Windows.Forms.ProgressBarStyle]::Marquee
    $ProgressBar.Left = 20
    $ProgressBar.Top = $Label.Bottom + 20
    $ProgressBar.Width = $Form.ClientSize.Width - 40
    $ProgressBar.Height = 25
    $Form.Controls.Add($ProgressBar)

    # Use a global variable or pass an object to store the form instance
    $Script:ProgressForm = $Form
    $Script:ProgressForm.Show() | Out-Null
    $Script:ProgressForm.Refresh() # Ensure it's drawn immediately
}

# Function to close the progress window
function Close-ProgressWindow {
    if ($Script:ProgressForm -ne $null -and !$Script:ProgressForm.IsDisposed) {
        $Script:ProgressForm.Close()
        $Script:ProgressForm.Dispose()
        $Script:ProgressForm = $null
    }
}

# Main GUI for all inputs
function Show-MainConfigurationGUI {
    $Form = New-Object System.Windows.Forms.Form
    $Form.Text = "Intune Win32 App Packaging Configuration"
    $Form.Size = New-Object System.Drawing.Size(700, 700) # Set initial size
    $Form.MinimumSize = $Form.Size # Prevent resizing smaller
    $Form.StartPosition = 'CenterScreen'
    $Form.MaximizeBox = $false # Standard boolean assignment
    $Form.MinimizeBox = $false # Standard boolean assignment
    $Form.FormBorderStyle = [System.Windows.Forms.FormBorderStyle]::FixedSingle # Fixed size

    $FontHeader = [System.Drawing.Font]::new("Microsoft Sans Serif", 12, [System.Drawing.FontStyle]::Bold)
    $FontNormal = [System.Drawing.Font]::new("Microsoft Sans Serif", 10)

    $yPos = 20
    $labelHeight = 20
    $textBoxHeight = 25
    $controlSpacing = 10
    $radioGroupHeight = 100 # Approx height for radio button group

    #region -- Global Inputs --
    $lblGlobal = New-Object System.Windows.Forms.Label
    $lblGlobal.Text = "Global Application Settings"
    $lblGlobal.Left = 20
    $lblGlobal.Top = $yPos
    $lblGlobal.AutoSize = $true # Standard boolean assignment
    $lblGlobal.Font = $FontHeader
    $Form.Controls.Add($lblGlobal)
    $yPos += $labelHeight + $controlSpacing

    $lblShortcutName = New-Object System.Windows.Forms.Label
    $lblShortcutName.Text = "App/Shortcut Name (e.g., 'MyCompanyApp'):"
    $lblShortcutName.Left = 20
    $lblShortcutName.Top = $yPos
    $lblShortcutName.AutoSize = $true # Standard boolean assignment
    $lblShortcutName.Font = $FontNormal
    $Form.Controls.Add($lblShortcutName)
    $yPos += $labelHeight

    $txtShortcutName = New-Object System.Windows.Forms.TextBox
    $txtShortcutName.Text = "MyApp"
    $txtShortcutName.Left = 20
    $txtShortcutName.Top = $yPos
    $txtShortcutName.Width = 300
    $txtShortcutName.Height = $textBoxHeight
    $txtShortcutName.Font = $FontNormal
    $Form.Controls.Add($txtShortcutName)
    $yPos += $textBoxHeight + $controlSpacing

    $lblShortcutVersion = New-Object System.Windows.Forms.Label
    $lblShortcutVersion.Text = "App/Shortcut Version (e.g., '1.0'):"
    $lblShortcutVersion.Left = 20
    $lblShortcutVersion.Top = $yPos
    $lblShortcutVersion.AutoSize = $true # Standard boolean assignment
    $lblShortcutVersion.Font = $FontNormal
    $Form.Controls.Add($lblShortcutVersion)
    $yPos += $labelHeight

    $txtShortcutVersion = New-Object System.Windows.Forms.TextBox
    $txtShortcutVersion.Text = "1.0"
    $txtShortcutVersion.Left = 20
    $txtShortcutVersion.Top = $yPos
    $txtShortcutVersion.Width = 100
    $txtShortcutVersion.Height = $textBoxHeight
    $txtShortcutVersion.Font = $FontNormal
    $Form.Controls.Add($txtShortcutVersion)
    $yPos += $textBoxHeight + $controlSpacing

    $lblOutputFolder = New-Object System.Windows.Forms.Label
    $lblOutputFolder.Text = "Output Folder for .intunewin file:"
    $lblOutputFolder.Left = 20
    $lblOutputFolder.Top = $yPos
    $lblOutputFolder.AutoSize = $true # Standard boolean assignment
    $lblOutputFolder.Font = $FontNormal
    $Form.Controls.Add($lblOutputFolder)
    $yPos += $labelHeight

    $txtOutputFolder = New-Object System.Windows.Forms.TextBox
    $txtOutputFolder.Text = "C:\Temp"
    $txtOutputFolder.Left = 20
    $txtOutputFolder.Top = $yPos
    $txtOutputFolder.Width = 400
    $txtOutputFolder.Height = $textBoxHeight
    $txtOutputFolder.ReadOnly = $true # Standard boolean assignment
    $txtOutputFolder.Font = $FontNormal
    $Form.Controls.Add($txtOutputFolder)

    $btnBrowseOutput = New-Object System.Windows.Forms.Button
    $btnBrowseOutput.Text = "Browse..."
    $btnBrowseOutput.Left = $txtOutputFolder.Right + 10
    $btnBrowseOutput.Top = $yPos
    $btnBrowseOutput.Width = 100
    $btnBrowseOutput.Height = $textBoxHeight
    $btnBrowseOutput.Add_Click({
        $selectedFolder = Get-FolderBrowserInput -Title "Select Output Folder" -InitialDirectory $txtOutputFolder.Text
        if ($selectedFolder) {
            $txtOutputFolder.Text = $selectedFolder
        }
    })
    $Form.Controls.Add($btnBrowseOutput)
    $yPos += $textBoxHeight + $controlSpacing * 2
    #endregion

    #region -- Main Action Type --
    $grpActionType = New-Object System.Windows.Forms.GroupBox
    $grpActionType.Text = "Choose Action Type"
    $grpActionType.Left = 20
    $grpActionType.Top = $yPos
    $grpActionType.Width = $Form.ClientSize.Width - 40
    $grpActionType.Height = 60 # Adjusted for radio buttons
    $grpActionType.Font = $FontNormal
    $Form.Controls.Add($grpActionType)

    $rbCreateShortcut = New-Object System.Windows.Forms.RadioButton
    $rbCreateShortcut.Text = "Create Shortcut"
    $rbCreateShortcut.Left = 20
    $rbCreateShortcut.Top = 20
    $rbCreateShortcut.AutoSize = $true # Standard boolean assignment
    $rbCreateShortcut.Checked = $true # Default # Standard boolean assignment
    $grpActionType.Controls.Add($rbCreateShortcut)

    $rbCopyFileFolder = New-Object System.Windows.Forms.RadioButton
    $rbCopyFileFolder.Text = "Copy File/Folder"
    $rbCopyFileFolder.Left = $rbCreateShortcut.Right + 50
    $rbCopyFileFolder.Top = 20
    $rbCopyFileFolder.AutoSize = $true # Standard boolean assignment
    $grpActionType.Controls.Add($rbCopyFileFolder)
    $yPos += $grpActionType.Height + $controlSpacing
    #endregion

    #region -- Shortcut Options (Conditional Visibility) --
    $grpShortcutOptions = New-Object System.Windows.Forms.GroupBox
    $grpShortcutOptions.Text = "Shortcut Configuration"
    $grpShortcutOptions.Left = 20
    $grpShortcutOptions.Top = $yPos
    $grpShortcutOptions.Width = $Form.ClientSize.Width - 40
    $grpShortcutOptions.Height = 250 # Ample space for content
    $grpShortcutOptions.Font = $FontNormal
    $Form.Controls.Add($grpShortcutOptions)

    $innerY = 20

    # Shortcut Target Type
    $lblTargetType = New-Object System.Windows.Forms.Label
    $lblTargetType.Text = "Shortcut Target Type:"
    $lblTargetType.Left = 20
    $lblTargetType.Top = $innerY
    $lblTargetType.AutoSize = $true # Standard boolean assignment
    $lblTargetType.Font = $FontNormal
    $grpShortcutOptions.Controls.Add($lblTargetType)
    $innerY += $labelHeight

    $rbTargetURL = New-Object System.Windows.Forms.RadioButton
    $rbTargetURL.Text = "URL"
    $rbTargetURL.Left = 20
    $rbTargetURL.Top = $innerY
    $rbTargetURL.AutoSize = $true # Standard boolean assignment
    $rbTargetURL.Checked = $true # Default # Standard boolean assignment
    $grpShortcutOptions.Controls.Add($rbTargetURL)

    $rbTargetFilePath = New-Object System.Windows.Forms.RadioButton
    $rbTargetFilePath.Text = "File Path"
    $rbTargetFilePath.Left = $rbTargetURL.Right + 20
    $rbTargetFilePath.Top = $innerY
    $rbTargetFilePath.AutoSize = $true # Standard boolean assignment
    $grpShortcutOptions.Controls.Add($rbTargetFilePath)

    $rbTargetMsApp = New-Object System.Windows.Forms.RadioButton
    $rbTargetMsApp.Text = "Microsoft Store App (AppUserModelID)"
    $rbTargetMsApp.Left = $rbTargetFilePath.Right + 20
    $rbTargetMsApp.Top = $innerY
    $rbTargetMsApp.AutoSize = $true # Standard boolean assignment
    $grpShortcutOptions.Controls.Add($rbTargetMsApp)
    $innerY += $labelHeight + $controlSpacing

    $lblTargetValue = New-Object System.Windows.Forms.Label
    $lblTargetValue.Text = "Target Value (URL, File Path, or App ID):"
    $lblTargetValue.Left = 20
    $lblTargetValue.Top = $innerY
    $lblTargetValue.AutoSize = $true # Standard boolean assignment
    $lblTargetValue.Font = $FontNormal
    $grpShortcutOptions.Controls.Add($lblTargetValue)
    $innerY += $labelHeight

    $txtTargetValue = New-Object System.Windows.Forms.TextBox
    $txtTargetValue.Text = "https://example.com"
    $txtTargetValue.Left = 20
    $txtTargetValue.Top = $innerY
    $txtTargetValue.Width = $grpShortcutOptions.ClientSize.Width - 150
    $txtTargetValue.Height = $textBoxHeight
    $txtTargetValue.Font = $FontNormal
    $grpShortcutOptions.Controls.Add($txtTargetValue)

    $btnBrowseTarget = New-Object System.Windows.Forms.Button
    $btnBrowseTarget.Text = "Browse..."
    $btnBrowseTarget.Left = $txtTargetValue.Right + 10
    $btnBrowseTarget.Top = $innerY
    $btnBrowseTarget.Width = 100
    $btnBrowseTarget.Height = $textBoxHeight
    $btnBrowseTarget.Add_Click({
        $selectedPath = Get-FileBrowserInput -Title "Select Target File" -Filter "Executable Files (*.exe)|*.exe|All Files (*.*)|*.*"
        if ($selectedPath) {
            $txtTargetValue.Text = $selectedPath
        }
    })
    $grpShortcutOptions.Controls.Add($btnBrowseTarget)
    $innerY += $textBoxHeight + $controlSpacing * 2

    # Shortcut Icon Path
    $lblIconPath = New-Object System.Windows.Forms.Label
    $lblIconPath.Text = "Shortcut Icon Path (.ico):"
    $lblIconPath.Left = 20
    $lblIconPath.Top = $innerY
    $lblIconPath.AutoSize = $true # Standard boolean assignment
    $lblIconPath.Font = $FontNormal
    $grpShortcutOptions.Controls.Add($lblIconPath)
    $innerY += $labelHeight

    $txtIconPath = New-Object System.Windows.Forms.TextBox
    $txtIconPath.Text = "C:\Windows\System32\shell32.dll,0" # Default for example or empty
    $txtIconPath.Left = 20
    $txtIconPath.Top = $innerY
    $txtIconPath.Width = $grpShortcutOptions.ClientSize.Width - 150
    $txtIconPath.Height = $textBoxHeight
    $txtIconPath.ReadOnly = $true # Standard boolean assignment
    $txtIconPath.Font = $FontNormal
    $grpShortcutOptions.Controls.Add($txtIconPath)

    $btnBrowseIcon = New-Object System.Windows.Forms.Button
    $btnBrowseIcon.Text = "Browse..."
    $btnBrowseIcon.Left = $txtIconPath.Right + 10
    $btnBrowseIcon.Top = $innerY
    $btnBrowseIcon.Width = 100
    $btnBrowseIcon.Height = $textBoxHeight
    $btnBrowseIcon.Add_Click({
        # Ensure the Filter string is correctly passed
        $selectedIcon = Get-FileBrowserInput -Title "Select Shortcut Icon" -Filter "Icon Files (*.ico)|*.ico|All Files (*.*)|*.*"
        if ($selectedIcon) {
            $txtIconPath.Text = $selectedIcon
        }
    })
    $grpShortcutOptions.Controls.Add($btnBrowseIcon)
    $innerY += $textBoxHeight + $controlSpacing * 2

    # Shortcut Location
    $lblShortcutLocation = New-Object System.Windows.Forms.Label
    $lblShortcutLocation.Text = "Shortcut Location:"
    $lblShortcutLocation.Left = 20
    $lblShortcutLocation.Top = $innerY
    $lblShortcutLocation.AutoSize = $true # Standard boolean assignment
    $lblShortcutLocation.Font = $FontNormal
    $grpShortcutOptions.Controls.Add($lblShortcutLocation)
    $innerY += $labelHeight

    $rbLocDesktop = New-Object System.Windows.Forms.RadioButton
    $rbLocDesktop.Text = "Desktop"
    $rbLocDesktop.Left = 20
    $rbLocDesktop.Top = $innerY
    $rbLocDesktop.AutoSize = $true # Standard boolean assignment
    $rbLocDesktop.Checked = $true # Default # Standard boolean assignment
    $grpShortcutOptions.Controls.Add($rbLocDesktop)

    $rbLocTaskbar = New-Object System.Windows.Forms.RadioButton
    $rbLocTaskbar.Text = "Taskbar (Pin)"
    $rbLocTaskbar.Left = $rbLocDesktop.Right + 20
    $rbLocTaskbar.Top = $innerY
    $rbLocTaskbar.AutoSize = $true # Standard boolean assignment
    $grpShortcutOptions.Controls.Add($rbLocTaskbar)

    $rbLocBoth = New-Object System.Windows.Forms.RadioButton
    $rbLocBoth.Text = "Both Desktop & Taskbar"
    $rbLocBoth.Left = $rbLocTaskbar.Right + 20
    $rbLocBoth.Top = $innerY
    $rbLocBoth.AutoSize = $true # Standard boolean assignment
    $grpShortcutOptions.Controls.Add($rbLocBoth)
    $innerY += $labelHeight + $controlSpacing # For future elements

    # Set initial visibility
    $grpShortcutOptions.Visible = $rbCreateShortcut.Checked
    $btnBrowseTarget.Visible = $rbTargetFilePath.Checked # Initially only visible for FilePath

    # Handle radio button clicks to update visibility and default text
    $rbCreateShortcut.Add_CheckedChanged({
        $grpShortcutOptions.Visible = $rbCreateShortcut.Checked
        $grpCopyFileFolder.Visible = -not $rbCreateShortcut.Checked
    })

    # Event handlers for Target Type radio buttons
    $rbTargetURL.Add_CheckedChanged({
        if ($rbTargetURL.Checked) {
            $lblTargetValue.Text = "URL (e.g., https://example.com):"
            $txtTargetValue.Text = "https://example.com"
            $btnBrowseTarget.Visible = $false # Standard boolean assignment
        }
    })
    $rbTargetFilePath.Add_CheckedChanged({
        if ($rbTargetFilePath.Checked) {
            $lblTargetValue.Text = "Target File Path (e.g., C:\Program Files\App\app.exe):"
            $txtTargetValue.Text = "C:\Program Files\MyApp\app.exe"
            $btnBrowseTarget.Visible = $true # Standard boolean assignment
        }
    })
    $rbTargetMsApp.Add_CheckedChanged({
        if ($rbTargetMsApp.Checked) { # Corrected from rbMsApp to rbTargetMsApp
            $lblTargetValue.Text = "AppUserModelID (e.g., Microsoft.CompanyPortal_8wekyb3d8bbwe!App):"
            $txtTargetValue.Text = "Microsoft.CompanyPortal_8wekyb3d8bbwe!App"
            $btnBrowseTarget.Visible = $false # Standard boolean assignment
        }
    })

    #endregion

    #region -- Copy File/Folder Options (Conditional Visibility) --
    $grpCopyFileFolder = New-Object System.Windows.Forms.GroupBox
    $grpCopyFileFolder.Text = "Copy File/Folder Configuration"
    $grpCopyFileFolder.Left = 20
    $grpCopyFileFolder.Top = $yPos # Same starting position as Shortcut Options
    $grpCopyFileFolder.Width = $Form.ClientSize.Width - 40
    $grpCopyFileFolder.Height = 100 # Adjusted for content
    $grpCopyFileFolder.Font = $FontNormal
    $Form.Controls.Add($grpCopyFileFolder)

    $innerYCopy = 20

    $lblCopySourcePath = New-Object System.Windows.Forms.Label
    $lblCopySourcePath.Text = "Source File or Folder Path:"
    $lblCopySourcePath.Left = 20
    $lblCopySourcePath.Top = $innerYCopy
    $lblCopySourcePath.AutoSize = $true # Standard boolean assignment
    $lblCopySourcePath.Font = $FontNormal
    $grpCopyFileFolder.Controls.Add($lblCopySourcePath)
    $innerYCopy += $labelHeight

    $txtCopySourcePath = New-Object System.Windows.Forms.TextBox
    $txtCopySourcePath.Text = "D:\MyDocument.pdf"
    $txtCopySourcePath.Left = 20
    $txtCopySourcePath.Top = $innerYCopy
    $txtCopySourcePath.Width = $grpCopyFileFolder.ClientSize.Width - 150
    $txtCopySourcePath.Height = $textBoxHeight
    $txtCopySourcePath.ReadOnly = $true # Standard boolean assignment
    $txtCopySourcePath.Font = $FontNormal
    $grpCopyFileFolder.Controls.Add($txtCopySourcePath)

    $btnBrowseCopySource = New-Object System.Windows.Forms.Button
    $btnBrowseCopySource.Text = "Browse..."
    $btnBrowseCopySource.Left = $txtCopySourcePath.Right + 10
    $btnBrowseCopySource.Top = $innerYCopy
    $btnBrowseCopySource.Width = 100
    $btnBrowseCopySource.Height = $textBoxHeight
    $btnBrowseCopySource.Add_Click({
        # Ensure filter is handled correctly
        $selectedItem = Get-FileBrowserInput -Title "Select File to Copy" -Filter "All Files (*.*)|*.*"
        if ($selectedItem) {
            $txtCopySourcePath.Text = $selectedItem
        }
    })
    $grpCopyFileFolder.Controls.Add($btnBrowseCopySource)

    # Set initial visibility (opposite of shortcut options)
    $grpCopyFileFolder.Visible = -not $rbCreateShortcut.Checked
    #endregion

    #region -- Action Buttons --
    $btnGenerate = New-Object System.Windows.Forms.Button
    $btnGenerate.Text = "Generate Package"
    $btnGenerate.Left = $Form.ClientSize.Width - 250
    $btnGenerate.Top = $Form.ClientSize.Height - 60 # Position near bottom
    $btnGenerate.Width = 120
    $btnGenerate.Height = 35
    $btnGenerate.Font = $FontNormal
    $Form.Controls.Add($btnGenerate)

    $btnCancel = New-Object System.Windows.Forms.Button
    $btnCancel.Text = "Cancel"
    $btnCancel.Left = $btnGenerate.Right + 10
    $btnCancel.Top = $Form.ClientSize.Height - 60
    $btnCancel.Width = 100
    $btnCancel.Height = 35
    $btnCancel.Font = $FontNormal
    $Form.Controls.Add($btnCancel)

    # Store results in a PSCustomObject
    $script:FormResult = $null

    # Event handlers for Generate/Cancel
    $btnGenerate.Add_Click({
        # --- Validation Logic ---
        $errors = @()

        if ([string]::IsNullOrWhiteSpace($txtShortcutName.Text)) { $errors += "Application/Shortcut Name is required." }
        if ([string]::IsNullOrWhiteSpace($txtShortcutVersion.Text)) { $errors += "Version is required." }
        if ([string]::IsNullOrWhiteSpace($txtOutputFolder.Text)) { $errors += "Output Folder is required." }
        elseif (-not (Test-Path $txtOutputFolder.Text -PathType Container)) { $errors += "Output Folder does not exist." }

        if ($rbCreateShortcut.Checked) {
            if ([string]::IsNullOrWhiteSpace($txtTargetValue.Text)) { $errors += "Shortcut Target Value is required." }

            if ($rbTargetFilePath.Checked) {
                 if (-not (Test-Path $txtTargetValue.Text)) { $errors += "Shortcut Target File Path does not exist." }
            } elseif ($rbTargetURL.Checked) {
                if (-not ($txtTargetValue.Text -match '^(https?|ftp|sftp|file)://')) {
                    $errors += "Invalid URL format for Shortcut Target. Must start with http(s)://, ftp://, sftp://, or file://."
                }
            }

            if ([string]::IsNullOrWhiteSpace($txtIconPath.Text)) { $errors += "Shortcut Icon Path is required." }
            elseif (-not (Test-Path $txtIconPath.Text -PathType Leaf)) { $errors += "Shortcut Icon file does not exist." }
            elseif ((Get-Item $txtIconPath.Text).Extension -ne ".ico") {
                # Allow DLL/EXE for icon, but warn
                if ($txtIconPath.Text -notmatch '\.(dll|exe|ico)$') {
                    $errors += "Shortcut Icon must be a .ico, .dll, or .exe file (or specify icon index, e.g., 'C:\path\to\file.dll,0')."
                }
            }

        } elseif ($rbCopyFileFolder.Checked) {
            if ([string]::IsNullOrWhiteSpace($txtCopySourcePath.Text)) { $errors += "Source File or Folder Path is required for copying." }
            elseif (-not (Test-Path $txtCopySourcePath.Text)) { $errors += "Source File or Folder for copying does not exist." }
        }

        if ($errors.Count -gt 0) {
            [System.Windows.Forms.MessageBox]::Show(($errors | Out-String), "Validation Error", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Warning)
            return # Do not close form
        }

        # Collect all inputs into a PSCustomObject
        $script:FormResult = [PSCustomObject]@{
            ShortcutName      = $txtShortcutName.Text.Trim()
            ShortcutVersion   = $txtShortcutVersion.Text.Trim()
            OutputFolder      = $txtOutputFolder.Text.Trim()
            ActionType        = if ($rbCreateShortcut.Checked) { "CreateShortCut" } else { "CopyFileFolder" }
            # Shortcut specific properties
            ShortcutTargetType = if ($rbCreateShortcut.Checked) {
                                     if ($rbTargetURL.Checked) { "URL" }
                                     elseif ($rbTargetFilePath.Checked) { "FilePath" }
                                     elseif ($rbTargetMsApp.Checked) { "MsApp" }
                                     else { $null } # Should not happen with validation
                                 } else { $null }
            ShortcutTarget     = if ($rbCreateShortcut.Checked) { $txtTargetValue.Text.Trim() } else { $null }
            ShortcutIcon       = if ($rbCreateShortcut.Checked) { $txtIconPath.Text.Trim() } else { $null }
            ShortcutLocation   = if ($rbCreateShortcut.Checked) {
                                     if ($rbLocDesktop.Checked) { "Desktop" }
                                     elseif ($rbLocTaskbar.Checked) { "Taskbar" }
                                     elseif ($rbLocBoth.Checked) { "Both" }
                                     else { $null } # Should not happen
                                 } else { $null }
            # Copy File/Folder specific property
            CopySourcePath     = if ($rbCopyFileFolder.Checked) { $txtCopySourcePath.Text.Trim() } else { $null }
        }
        $Form.Close()
    })

    $btnCancel.Add_Click({
        $script:FormResult = $null # Indicate cancellation
        $Form.Close()
    })
    #endregion

    $Form.ShowDialog() | Out-Null
    return $script:FormResult
}
#endregion

#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++#
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++#

#region Main Script Logic Execution

# Define common paths (LogFile needs to be defined early for Write-Log to work)
$WorkingDir = Join-Path -Path $env:TEMP -ChildPath "IntuneWinPackage\TempApp" # Placeholder name for initial log setup
$Script:LogFile = Join-Path -Path $WorkingDir -ChildPath "PackagingLog.txt"

# Create a temporary working directory for initial logging
try {
    New-Item -ItemType Directory -Path $WorkingDir -Force | Out-Null
} catch {
    Show-ErrorAndExit -Message "Failed to create initial working directory: $WorkingDir. Error: $($_.Exception.Message)" `
                      -LogMessage "Failed to create initial working directory: $WorkingDir. Error: $($_.Exception.Message)"
}


Write-Log -Message "Script started. Initial log file: $Script:LogFile" -LogFile $Script:LogFile

# Get all inputs from the single GUI window
$UserInput = Show-MainConfigurationGUI

if ($UserInput -eq $null) {
    Show-ErrorAndExit -Message 'Script terminated by user cancellation or no inputs provided.' -LogMessage 'User cancelled main GUI. Exiting script.' -LogFile $Script:LogFile
}

# Update WorkingDir and LogFile path based on UserInput.ShortcutName
$ShortcutName = $UserInput.ShortcutName
$WorkingDir = Join-Path -Path $env:TEMP -ChildPath "IntuneWinPackage\$ShortcutName"
$Script:LogFile = Join-Path -Path $WorkingDir -ChildPath "PackagingLog.txt" # Update log file path

# Recreate working directory (or ensure it exists) with the correct app name
try {
    New-Item -ItemType Directory -Path $WorkingDir -Force | Out-Null
} catch {
    Show-ErrorAndExit -Message "Failed to create final working directory: $WorkingDir. Error: $($_.Exception.Message)" `
                      -LogMessage "Failed to create final working directory: $WorkingDir. Error: $($_.Exception.Message)" -LogFile $Script:LogFile
}

Write-Log -Message "User provided Shortcut Name: $($UserInput.ShortcutName)" -LogFile $Script:LogFile
Write-Log -Message "User provided Version: $($UserInput.ShortcutVersion)" -LogFile $Script:LogFile
Write-Log -Message "User provided Output Folder: $($UserInput.OutputFolder)" -LogFile $Script:LogFile
Write-Log -Message "User chose Action Type: $($UserInput.ActionType)" -LogFile $Script:LogFile

if ($UserInput.ActionType -eq "CreateShortCut") {
    Write-Log -Message "Shortcut Target Type: $($UserInput.ShortcutTargetType)" -LogFile $Script:LogFile
    Write-Log -Message "Shortcut Target: $($UserInput.ShortcutTarget)" -LogFile $Script:LogFile
    Write-Log -Message "Shortcut Icon Path: $($UserInput.ShortcutIcon)" -LogFile $Script:LogFile
    Write-Log -Message "Shortcut Location: $($UserInput.ShortcutLocation)" -LogFile $Script:LogFile
} else { # CopyFileFolder
    Write-Log -Message "Copy Source Path: $($UserInput.CopySourcePath)" -LogFile $Script:LogFile
}


# Check IntuneWinAppUtil for packaging
$IntuneWinAppUtilPath = "IntuneWinAppUtil.exe" # Changed to just filename, relying on $PSScriptRoot later
$IntuneWinFile = Join-Path -Path $UserInput.OutputFolder -ChildPath "Install_$ShortcutName.intunewin"

if (-not (Test-Path "$PSScriptRoot\$IntuneWinAppUtilPath")) { # Check using PSScriptRoot
    Show-ErrorAndExit -Message "IntuneWinAppUtil.exe not found at '$PSScriptRoot\$IntuneWinAppUtilPath'. Please place it in the script's directory."`
                      -LogMessage "IntuneWinAppUtil.exe not found. Exiting script." -LogFile $Script:LogFile
} elseif (Test-Path $IntuneWinFile) {
    # Pass a generic name for the prompt
    if (-not (DeleteFileWithConfirmation -FilePath $IntuneWinFile -LogFile $Script:LogFile -FileNameForPrompt "$ShortcutName.intunewin")) {
        # Script would have exited if user chose No, so this path means deletion failed
        Show-ErrorAndExit -Message "Failed to delete existing .intunewin file. Exiting." `
                          -LogMessage "Failed to delete existing .intunewin file. Exiting." -LogFile $Script:LogFile
    }
}


# Create Version, Install, Uninstall, Detection, Instructions files for Intune
$InstallScriptPath = Join-Path -Path $WorkingDir -ChildPath "Install_$ShortcutName.ps1"
$UninstallScriptPath = Join-Path -Path $WorkingDir -ChildPath "Uninstall_$ShortcutName.ps1"
$DetectionScriptPath = Join-Path -Path $WorkingDir -ChildPath "Detection_$ShortcutName.ps1"
$InstructionsFilePath = Join-Path -Path $UserInput.OutputFolder -ChildPath "IntuneInstructions_$ShortcutName.txt"
$ShortcutVersionInstallPath = Join-Path -Path $WorkingDir -ChildPath "$ShortcutVersion.ini"


# Create Version file for Intune
@"
# Version.ini
# Version control
$ShortcutVersion
"@ | Set-Content -Path $ShortcutVersionInstallPath -Encoding UTF8
Write-Log -Message "Created version file: $ShortcutVersionInstallPath" -LogFile $Script:LogFile

# Generate common paths for installation scripts
$PublicDesktopFolder = "C:\Users\Public\Desktop"
$ShortcutIconPath = "C:\ProgramData\ShortcutsIcons"
$ShortcutVersionPath = "C:\ProgramData\ShortcutsVersion\$ShortcutName"
$CurrentUserDesktop = "$env:USERPROFILE\Desktop" # For per-user desktop
$CurrentUserTaskbarPin = "$env:APPDATA\Microsoft\Internet Explorer\Quick Launch\User Pinned\TaskBar" # Not a direct path, requires COM for pinning

# Helper function for pinning to taskbar (requires a shortcut file)
$PinToTaskbarScriptBlock = @"
function Pin-ToTaskbar {
    param (
        [string]`$ShortcutPath
    )
    `$Shell = New-Object -ComObject Shell.Application
    `$Folder = `$Shell.Namespace((Split-Path -Path `$ShortcutPath -Parent))
    `$Item = `$Folder.ParseName((Split-Path -Path `$ShortcutPath -Leaf))
    `$Verb = `$Item.Verbs() | Where-Object { `$_.Name -eq "Pin to Tas&kbar" }
    if (`$Verb) {
        try {
            `$Verb.DoIt()
            Write-Host "Successfully pinned `$ShortcutPath to Taskbar."
        } catch {
            Write-Host "Failed to pin `$ShortcutPath to Taskbar. Error: `$(````$_.Exception.Message)"
            exit 1
        }
    } else {
        Write-Host "Could not find 'Pin to Taskbar' verb for `$ShortcutPath. Skipping taskbar pin."
    }
}
"@

# Helper function for unpinning from taskbar (requires a shortcut file)
$UnpinFromTaskbarScriptBlock = @"
function Unpin-FromTaskbar {
    param (
        [string]`$ShortcutPath
    )
    `$Shell = New-Object -ComObject Shell.Application
    `$Folder = `$Shell.Namespace((Split-Path -Path `$ShortcutPath -Parent))
    `$Item = `$Folder.ParseName((Split-Path -Path `$ShortcutPath -Leaf))
    `$Verb = `$Item.Verbs() | Where-Object { `$_.Name -eq "Unpin from Tas&kbar" } # Note: "&" for Alt key
    if (`$Verb) {
        try {
            `$Verb.DoIt()
            Write-Host "Successfully unpinned `$ShortcutPath from Taskbar."
        } catch {
            Write-Host "Failed to unpin `$ShortcutPath from Taskbar. Error: `$(````$_.Exception.Message)"
            exit 1
        }
    } else {
        Write-Host "Could not find 'Unpin from Taskbar' verb for `$ShortcutPath. Skipping taskbar unpin."
    }
}
"@


#++++++++++++++++++++++++++++++++++++++++++#

# Process the user's choice
if ($UserInput.ActionType -eq "CopyFileFolder") {

    $CopyFile = $UserInput.CopySourcePath # Use value from GUI

    # Copy the selected file/folder to the working directory
    try {
        Copy-Item -Path $CopyFile -Destination $WorkingDir -Recurse -Force -ErrorAction Stop
        $FileName = [System.IO.Path]::GetFileName($CopyFile)
        Write-Log -Message "Copied file/folder '$FileName' to: $WorkingDir" -LogFile $Script:LogFile
    }
    catch {
        Show-ErrorAndExit -Message "Failed to copy file/folder '$CopyFile' to working directory. Error: $($_.Exception.Message)" `
                          -LogMessage "Failed to copy file/folder '$CopyFile'. Error: $($_.Exception.Message)" -LogFile $Script:LogFile
    }

# Create Install file for Intune
@"
# Install_$ShortcutName.ps1
# Copy item to Public Desktop folder

\$PublicDesktopFolder = "C:\Users\Public\Desktop"
\$ShortcutVersionPath = "C:\ProgramData\ShortcutsVersion\$ShortcutName"
\$FileName = "$FileName" # Ensure filename is correctly passed
\$ShortcutVersion = "$ShortcutVersion"

# Copy the item to the Public Desktop folder
try {
    Copy-Item -Path ".\$FileName" -Destination "\$PublicDesktopFolder" -Recurse -Force -ErrorAction Stop
    Write-Host "Successfully copied '$FileName' to \$PublicDesktopFolder."
} catch {
    Write-Host "Failed to copy '$FileName' to \$PublicDesktopFolder. Error: `$(````$_.Exception.Message)"
    exit 1
}

# Ensure the Shortcut Version Path exists and copy the version file
if (-not (Test-Path "\$ShortcutVersionPath")) {
    try {
        New-Item -ItemType Directory -Path "\$ShortcutVersionPath" -Force | Out-Null
        Write-Host "Created version directory: \$ShortcutVersionPath"
    } catch {
        Write-Host "Failed to create version directory: \$ShortcutVersionPath. Error: `$(````$_.Exception.Message)"
        exit 1
    }
}
try {
    Copy-Item -Path ".\$ShortcutVersion.ini" -Destination "\$ShortcutVersionPath" -Force -ErrorAction Stop
    Write-Host "Successfully copied version file to \$ShortcutVersionPath."
} catch {
    Write-Host "Failed to copy version file to \$ShortcutVersionPath. Error: `$(````$_.Exception.Message)"
    exit 1
}
"@ | Set-Content -Path $InstallScriptPath -Encoding UTF8

# Log the creation of the install script
Write-Log -Message "Created install script: $InstallScriptPath" -LogFile $Script:LogFile

# Create Uninstall file for Intune
@"
# Uninstall_$ShortcutName.ps1
# Remove item from Public Desktop folder

\$PublicDesktopFolder = "C:\Users\Public\Desktop"
\$ShortcutVersionPath = "C:\ProgramData\ShortcutsVersion\$ShortcutName"
\$FileName = "$FileName"
\$ShortcutVersion = "$ShortcutVersion"

# Remove the item from the Public Desktop folder
try {
    if (Test-Path "\$PublicDesktopFolder\$FileName") {
        Remove-Item -Path "\$PublicDesktopFolder\$FileName" -Recurse -Force -ErrorAction Stop
        Write-Host "Successfully removed '$FileName' from \$PublicDesktopFolder."
    } else {
        Write-Host "'$FileName' not found on desktop. Skipping removal."
    }
} catch {
    Write-Host "Failed to remove '$FileName' from \$PublicDesktopFolder. Error: `$(````$_.Exception.Message)"
    exit 1
}

# Remove the version file and its directory if empty
try {
    if (Test-Path "\$ShortcutVersionPath\$ShortcutVersion.ini") {
        Remove-Item -Path "\$ShortcutVersionPath\$ShortcutVersion.ini" -Force -ErrorAction Stop
        Write-Host "Successfully removed version file."
    } else {
        Write-Host "Version file not found. Skipping removal."
    }
    # Attempt to remove the version directory if it becomes empty
    if ((Test-Path "\$ShortcutVersionPath") -and (-not (Get-ChildItem -Path "\$ShortcutVersionPath"))) {
        Remove-Item -Path "\$ShortcutVersionPath" -Recurse -Force -ErrorAction SilentlyContinue
        Write-Host "Removed empty version directory: \$ShortcutVersionPath"
    }
} catch {
    Write-Host "Failed to remove version file or directory. Error: `$(````$_.Exception.Message)"
    exit 1
}
"@ | Set-Content -Path $UninstallScriptPath -Encoding UTF8

# Log the creation of the uninstall script
Write-Log -Message "Created uninstall script: $UninstallScriptPath" -LogFile $Script:LogFile

# Create Detection file for Intune
@"
# Detection_$ShortcutName.ps1
# Detection Script for $ShortcutName (Copy File/Folder)

\$PublicDesktopFolder = "C:\Users\Public\Desktop"
\$ShortcutVersionPath = "C:\ProgramData\ShortcutsVersion\$ShortcutName"
\$FileName = "$FileName"
\$ShortcutVersion = "$ShortcutVersion"

# Check if the version file and item are present
if ((Test-Path "\$ShortcutVersionPath\$ShortcutVersion.ini") -and (Test-Path "\$PublicDesktopFolder\$FileName")) {
    Write-Host "Version .ini file and item installation detected."
    exit 0
} else {
    Write-Host "Version .ini file or item installation not detected."
    exit 1
}
"@ | Set-Content -Path $DetectionScriptPath -Encoding UTF8

# Log the creation of the detection script
Write-Log -Message "Created detection script: $DetectionScriptPath" -LogFile $Script:LogFile

}elseif ($UserInput.ActionType -eq "CreateShortCut") {

    $ShortcutTargetType = $UserInput.ShortcutTargetType
    $ShortcutTarget = $UserInput.ShortcutTarget
    $ShortcutIcon = $UserInput.ShortcutIcon
    $ShortcutLocation = $UserInput.ShortcutLocation

    # Generate shortcut (.lnk) file in working directory
    $ShortcutPath = Join-Path -Path $WorkingDir -ChildPath "$ShortcutName.lnk"
    try {
        $WScriptShell = New-Object -ComObject WScript.Shell
        $Shortcut = $WScriptShell.CreateShortcut($ShortcutPath)
        if ($ShortcutTargetType.ToLower() -eq 'msapp') {
            $Shortcut.TargetPath = "%windir%\explorer.exe"
            $Shortcut.Arguments = $ShortcutTarget
        } else {
            $Shortcut.TargetPath = $ShortcutTarget
        }
        $Shortcut.IconLocation = "%ALLUSERSPROFILE%\ShortcutsIcons\$ShortcutName.ico" # Use %ALLUSERSPROFILE% for icon path
        $Shortcut.Save()
        Write-Log -Message "Created shortcut: $ShortcutPath" -LogFile $Script:LogFile
    }
    catch {
        Show-ErrorAndExit -Message "Failed to create shortcut file. Error: $($_.Exception.Message)" `
                          -LogMessage "Failed to create shortcut file. Error: $($_.Exception.Message)" -LogFile $Script:LogFile
    }

    # Copy the shortcut icon to working directory
    try {
        Copy-Item -Path "$ShortcutIcon" -Destination "$WorkingDir\$ShortcutName.ico" -Force -ErrorAction Stop
        Write-Log -Message "Copied icon to: $WorkingDir\$ShortcutName.ico" -LogFile $Script:LogFile
    }
    catch {
        Show-ErrorAndExit -Message "Failed to copy shortcut icon. Error: $($_.Exception.Message)" `
                          -LogMessage "Failed to copy shortcut icon. Error: $($_.Exception.Message)" -LogFile $Script:LogFile
    }

# Build Install script content
$InstallScriptContent = @"
# Install_$ShortcutName.ps1
# Create shortcut
$PinToTaskbarScriptBlock

\$PublicDesktopFolder = "C:\Users\Public\Desktop"
\$CurrentUserDesktop = "$env:USERPROFILE\Desktop" # This runs as SYSTEM usually, so not ideal for user desktop
\$ShortcutIconPath = "C:\ProgramData\ShortcutsIcons"
\$ShortcutVersionPath = "C:\ProgramData\ShortcutsVersion\$ShortcutName"
\$ShortcutName = "$ShortcutName"
\$ShortcutVersion = "$ShortcutVersion"

# Ensure the ShortcutIconPath directory exists, then copy the icon
if (-not (Test-Path "\$ShortcutIconPath")) {
    try {
        New-Item -ItemType Directory -Path "\$ShortcutIconPath" -Force | Out-Null
        Write-Host "Created icon directory: \$ShortcutIconPath"
    } catch {
        Write-Host "Failed to create icon directory: \$ShortcutIconPath. Error: `$(````$_.Exception.Message)"
        exit 1
    }
}
try {
    Copy-Item -Path ".\$ShortcutName.ico" -Destination "\$ShortcutIconPath" -Force -ErrorAction Stop
    Write-Host "Successfully copied icon to \$ShortcutIconPath."
} catch {
    Write-Host "Failed to copy icon to \$ShortcutIconPath. Error: `$(````$_.Exception.Message)"
    exit 1
}

# Ensure the ShortcutVersionPath directory exists, then copy the version info
if (-not (Test-Path "\$ShortcutVersionPath")) {
    try {
        New-Item -ItemType Directory -Path "\$ShortcutVersionPath" -Force | Out-Null
        Write-Host "Created version directory: \$ShortcutVersionPath"
    } catch {
        Write-Host "Failed to create version directory: \$ShortcutVersionPath. Error: `$(````$_.Exception.Message)"
        exit 1
    }
}
try {
    Copy-Item -Path ".\$ShortcutVersion.ini" -Destination "\$ShortcutVersionPath" -Force -ErrorAction Stop
    Write-Host "Successfully copied version file to \$ShortcutVersionPath."
} catch {
    Write-Host "Failed to copy version file to \$ShortcutVersionPath. Error: `$(````$_.Exception.Message)"
    exit 1
}

"@

if ($ShortcutLocation -eq "Desktop" -or $ShortcutLocation -eq "Both") {
    # Desktop shortcut (Public Desktop for all users)
    $InstallScriptContent += @"
# Copy shortcut to Public Desktop folder
try {
    Copy-Item -Path ".\$ShortcutName.lnk" -Destination "\$PublicDesktopFolder" -Force -ErrorAction Stop
    Write-Host "Successfully copied shortcut to \$PublicDesktopFolder."
} catch {
    Write-Host "Failed to copy shortcut to \$PublicDesktopFolder. Error: `$(````$_.Exception.Message)"
    exit 1
}

"@
}

if ($ShortcutLocation -eq "Taskbar" -or $ShortcutLocation -eq "Both") {
    # Taskbar pinning (requires a bit more logic and might need user context for dynamic pinning)
    # For SYSTEM context deployment, pinning to taskbar is tricky.
    # Usually, this needs to be done in user context or use scheduled task.
    # For Win32 app, best approach is often deploying a script that runs in 'User' context.
    # This example will pin the deployed shortcut, assuming the shortcut path is accessible.
    # NOTE: Pinning to taskbar often fails when running as SYSTEM. Consider a User Context script for reliability.
    $InstallScriptContent += @"
# Pin shortcut to Taskbar
# IMPORTANT: Pinning to Taskbar typically requires running in USER CONTEXT.
# If this script runs as SYSTEM, pinning might fail or only apply to the SYSTEM user.
# For robust user-specific pinning, consider a separate PowerShell script deployed in 'User' context.
try {
    `$ShortcutToPin = Join-Path -Path "\$PublicDesktopFolder" -ChildPath "\$ShortcutName.lnk"
    # Ensure the shortcut exists before trying to pin
    if (Test-Path `$ShortcutToPin) {
        Pin-ToTaskbar -ShortcutPath `$ShortcutToPin
    } else {
        Write-Host "Shortcut '`$ShortcutToPin' not found on desktop. Skipping taskbar pinning."
    }
} catch {
    Write-Host "Failed to attempt taskbar pinning. Error: `$(````$_.Exception.Message)"
}

"@
}

$InstallScriptContent | Set-Content -Path $InstallScriptPath -Encoding UTF8
Write-Log -Message "Created install script: $InstallScriptPath" -LogFile $Script:LogFile

# Build Uninstall script content
$UninstallScriptContent = @"
# Uninstall_$ShortcutName.ps1
# Remove shortcut
$UnpinFromTaskbarScriptBlock

\$PublicDesktopFolder = "C:\Users\Public\Desktop"
\$ShortcutIconPath = "C:\ProgramData\ShortcutsIcons"
\$ShortcutVersionPath = "C:\ProgramData\ShortcutsVersion\$ShortcutName"
\$ShortcutName = "$ShortcutName"
\$ShortcutVersion = "$ShortcutVersion"
"@

if ($ShortcutLocation -eq "Desktop" -or $ShortcutLocation -eq "Both") {
    $UninstallScriptContent += @"
# Remove the shortcut from the Public Desktop folder
try {
    if (Test-Path "\$PublicDesktopFolder\$ShortcutName.lnk") {
        Remove-Item -Path "\$PublicDesktopFolder\$ShortcutName.lnk" -Force -ErrorAction Stop
        Write-Host "Successfully removed shortcut from \$PublicDesktopFolder."
    } else {
        Write-Host "Shortcut not found on desktop. Skipping desktop removal."
    }
} catch {
    Write-Host "Failed to remove shortcut from \$PublicDesktopFolder. Error: `$(````$_.Exception.Message)"
    exit 1
}

"@
}

if ($ShortcutLocation -eq "Taskbar" -or $ShortcutLocation -eq "Both") {
    $UninstallScriptContent += @"
# Unpin shortcut from Taskbar
# As with pinning, unpinning may also require user context.
try {
    `$ShortcutToUnpin = Join-Path -Path "\$PublicDesktopFolder" -ChildPath "\$ShortcutName.lnk"
    if (Test-Path `$ShortcutToUnpin) {
        Unpin-FromTaskbar -ShortcutPath `$ShortcutToUnpin
    } else {
        Write-Host "Shortcut '`$ShortcutToUnpin' not found. Skipping taskbar unpin."
    }
} catch {
    Write-Host "Failed to attempt taskbar unpinning. Error: `$(````$_.Exception.Message)"
}

"@
}

$UninstallScriptContent += @"
# Remove version file
try {
    if (Test-Path "\$ShortcutVersionPath\$ShortcutVersion.ini") {
        Remove-Item -Path "\$ShortcutVersionPath\$ShortcutVersion.ini" -Force -ErrorAction Stop
        Write-Host "Successfully removed version file."
    } else {
        Write-Host "Version file not found. Skipping removal."
    }
    # Attempt to remove the version directory if it becomes empty
    if ((Test-Path "\$ShortcutVersionPath") -and (-not (Get-ChildItem -Path "\$ShortcutVersionPath"))) {
        Remove-Item -Path "\$ShortcutVersionPath" -Recurse -Force -ErrorAction SilentlyContinue
        Write-Host "Removed empty version directory: \$ShortcutVersionPath"
    }
} catch {
    Write-Host "Failed to remove version file or directory. Error: `$(````$_.Exception.Message)"
    exit 1
}

# Remove icon file and its directory if empty
try {
    if (Test-Path "\$ShortcutIconPath\$ShortcutName.ico") {
        Remove-Item -Path "\$ShortcutIconPath\$ShortcutName.ico" -Force -ErrorAction Stop
        Write-Host "Successfully removed icon file."
    } else {
        Write-Host "Icon file not found. Skipping removal."
    }
    # Attempt to remove the icon directory if it becomes empty
    if ((Test-Path "\$ShortcutIconPath") -and (-not (Get-ChildItem -Path "\$ShortcutIconPath"))) {
        Remove-Item -Path "\$ShortcutIconPath" -Recurse -Force -ErrorAction SilentlyContinue
        Write-Host "Removed empty icon directory: \$ShortcutIconPath"
    }
} catch {
    Write-Host "Failed to remove icon file or directory. Error: `$(````$_.Exception.Message)"
    exit 1
}
"@
$UninstallScriptContent | Set-Content -Path $UninstallScriptPath -Encoding UTF8

Write-Log -Message "Created uninstall script: $UninstallScriptPath" -LogFile $Script:LogFile

# Create Detection file for Intune
@"
# Detection_$ShortcutName.ps1
# Detection Script for $ShortcutName (Shortcut)

\$PublicDesktopFolder = "C:\Users\Public\Desktop"
\$ShortcutVersionPath = "C:\ProgramData\ShortcutsVersion\$ShortcutName"
\$ShortcutName = "$ShortcutName"
\$ShortcutVersion = "$ShortcutVersion"

# Primary detection: Check version file
if (-not (Test-Path "\$ShortcutVersionPath\$ShortcutVersion.ini")) {
    Write-Host "Version .ini file not detected."
    exit 1 # Not installed
}

# Secondary detection: Check shortcut presence based on deployment location
\$isDetected = \$false
if ("$($ShortcutLocation)" -eq "Desktop" -or "$($ShortcutLocation)" -eq "Both") {
    if (Test-Path "\$PublicDesktopFolder\$ShortcutName.lnk") {
        \$isDetected = \$true
        Write-Host "Shortcut detected on Public Desktop."
    }
}
# Note: Taskbar pinning detection is very difficult from SYSTEM context.
# We primarily rely on the version file and the desktop shortcut for detection if applicable.
# If only taskbar is chosen, the version file becomes the primary (and possibly only reliable) detection.
if ("$($ShortcutLocation)" -eq "Taskbar" -or "$($ShortcutLocation)" -eq "Both") {
    # Real taskbar detection is hard. Relying on version file and hoping pinning succeeded.
    # A more robust detection for taskbar might involve checking the shortcut's existence
    # for the specific user, which is problematic for SYSTEM context detection.
    # For this script, we'll assume if version file exists and desktop shortcut (if chosen) exists, it's detected.
    # If only taskbar is chosen, this is a weaker detection, relying mostly on the version file.
    if ("$($ShortcutLocation)" -eq "Taskbar" -and -not (Test-Path "\$PublicDesktopFolder\$ShortcutName.lnk")) {
        # If only taskbar is chosen, and public desktop shortcut doesn't exist, we rely solely on version.
        # This is a simplification. For true taskbar detection, often requires user-specific context.
        Write-Host "Taskbar-only deployment detection: Relying on version file only due to context limitations."
        \$isDetected = \$true # Assume detection if version exists
    }
}

if (\$isDetected) {
    Write-Host "Installation detected based on version file and shortcut location."
    exit 0 # Detected
} else {
    Write-Host "Installation not fully detected."
    exit 1 # Not detected
}
"@ | Set-Content -Path $DetectionScriptPath -Encoding UTF8

Write-Log -Message "Created detection script: $DetectionScriptPath" -LogFile $Script:LogFile

} # End if ($UserInput.ActionType -eq "CreateShortCut")


# Create instructions file for Intune
@"
Intune Packaging Instructions for $ShortcutName :

Install Command: powershell.exe -ExecutionPolicy Bypass -File ".\Install_$ShortcutName.ps1"
Uninstall Command: powershell.exe -ExecutionPolicy Bypass -File ".\Uninstall_$ShortcutName.ps1"
Detection Rules: Custom Detection Script (.\Detection_$ShortcutName.ps1)
Program Data:
  Source folder: .\
  Setup file: Install_$ShortcutName.ps1
"@ | Set-Content -Path $InstructionsFilePath -Encoding UTF8
Write-Log -Message "Created instructions file: $InstructionsFilePath" -LogFile $Script:LogFile


$IntuneUtilOutputLog = Join-Path -Path $WorkingDir -ChildPath "IntuneWinUtilOutput.txt"
$IntuneWinAppUtilPath = "IntuneWinAppUtil.exe" # This assumes IntuneWinAppUtil.exe is in the same directory as the script.

Show-ProgressWindow -Title "Packaging Win32 App..." -Message "Creating .intunewin file, please wait. This may take a moment."
Write-Log -Message "Executing IntuneWinAppUtil.exe" -LogFile $Script:LogFile

try {
    # Construct arguments separately for clarity
    $Arguments = @(
        '-c', "$WorkingDir", # No extra quotes needed here, Start-Process handles them for -ArgumentList
        '-s', "$InstallScriptPath",
        '-o', "$UserInput.OutputFolder" # Use UserInput.OutputFolder here
    )

    # Execute IntuneWinAppUtil.exe directly and capture output
    # This will directly capture stdout/stderr to the log file
    $Process = Start-Process -FilePath "$PSScriptRoot\$IntuneWinAppUtilPath" `
                             -ArgumentList $Arguments `
                             -Wait `
                             -PassThru `
                             -WindowStyle Hidden `
                             -RedirectStandardOutput $IntuneUtilOutputLog `
                             -RedirectStandardError $IntuneUtilOutputLog `
                             -ErrorAction Stop

    $ExitCode = $Process.ExitCode

}
catch {
    Close-ProgressWindow
    Show-ErrorAndExit -Message "Failed to start IntuneWinAppUtil.exe. Error: $($_.Exception.Message)" `
                      -LogMessage "Failed to start IntuneWinAppUtil.exe. Error: $($_.Exception.Message)" -LogFile $Script:LogFile
}
finally {
    Close-ProgressWindow
}

Write-Log -Message "IntuneWinAppUtil.exe process exit code: $ExitCode" -LogFile $Script:LogFile

# Handle process exit codes
if ($ExitCode -eq 0) {
    Write-Log -Message "Packaging completed successfully! .intunewin file is located at $UserInput.OutputFolder\Install_$ShortcutName.intunewin" -LogFile $Script:LogFile
    [System.Windows.Forms.MessageBox]::Show("Packaging completed successfully! The .intunewin file is located at:`n$UserInput.OutputFolder\Install_$ShortcutName.intunewin", "Success", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Information)

    # Prompt for cleanup
    $CleanupChoice = [System.Windows.Forms.MessageBox]::Show("Packaging is complete. Do you want to clean up the temporary working directory ($WorkingDir)?", "Cleanup Confirmation", [System.Windows.Forms.MessageBoxButtons]::YesNo, [System.Windows.Forms.MessageBoxIcon]::Question)
    if ($CleanupChoice -eq [System.Windows.Forms.DialogResult]::Yes) {
        try {
            Remove-Item -Path $WorkingDir -Recurse -Force -ErrorAction Stop
            Write-Log -Message "Cleaned up working directory: $WorkingDir" -LogFile $Script:LogFile
            [System.Windows.Forms.MessageBox]::Show("Temporary working directory cleaned up successfully.", "Cleanup Complete", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Information)
        }
        catch {
            Write-Log -Message "Failed to clean up working directory: $WorkingDir. Error: $($_.Exception.Message)" -LogFile $Script:LogFile
            [System.Windows.Forms.MessageBox]::Show("Failed to clean up temporary working directory. Error: $($_.Exception.Message)", "Cleanup Error", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Warning)
        }
    } else {
        Write-Log -Message "User chose not to clean up working directory: $WorkingDir" -LogFile $Script:LogFile
    }

} else {
    $ErrorDetails = ""
    if (Test-Path $IntuneUtilOutputLog) {
        $ErrorDetails = Get-Content -Path $IntuneUtilOutputLog -ErrorAction SilentlyContinue | Out-String
    }

    $ErrorMessage = "Packaging failed with exit code $ExitCode."
    if ($ErrorDetails) {
        $ErrorMessage += "`nDetails from IntuneWinAppUtil.exe:`n$ErrorDetails"
    }

    Write-Log -Message $ErrorMessage -LogFile $Script:LogFile
    Show-ErrorAndExit -Message $ErrorMessage -LogMessage $ErrorMessage -LogFile $Script:LogFile
}

# Final cleanup of the output log from IntuneWinAppUtil, if it exists
Remove-Item -Path $IntuneUtilOutputLog -ErrorAction SilentlyContinue

#endregion